# Exploit Protection Bypassing

## Detect Enabled Protections <a href="#docs-internal-guid-39923e30-7fff-1eb7-44df-03cf31a836cb" id="docs-internal-guid-39923e30-7fff-1eb7-44df-03cf31a836cb"></a>

You can use the checksec script from pwntools for ELF executables:

```
pwn checksec target
```

## Return Oriented Programming <a href="#docs-internal-guid-f62655c6-7fff-59ca-6029-47674aaea71d" id="docs-internal-guid-f62655c6-7fff-59ca-6029-47674aaea71d"></a>

### **Finding ROP Gadgets**

#### **msfelfscan**

Benefits:

* Is more abstract, searches for things that get you the desired result instead of specific instructions

Drawbacks:

* Has no option to only search executable memory regions afaik.
* **Doesn't work** if you're on a 64-bit machine and trying to find ROP gadgets for a 32-bit binary

**Installation**

You need metasploit-framework:

```
sudo apt install metasploit-framework
```

Then you need to install the necessary ruby gem(s):

```
sudo gem install rex-bin_tools
```

And after that, you should be able to use msfelfscan:

```
locate msfelfscan
/usr/share/metasploit-framework/vendor/bundle/ruby/2.7.0/bin/msfelfscan
```

#### **Usage**

Useful flags:

* `-j` to look for jumps to specific places/things

For example, the following command looks for jumps to esp:

```
msfelfscan -j esp /path/to/executable
```

**Warning**: It will also display gadgets that are in non-executable memory segments.

You can use `readelf` to see which memory segments are executable. Look for LOAD types with the **E** (execute) flag. For example:

```
readelf executable --segments
Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
LOAD           0x001000 0x08049000 0x08049000 0x6d444 0x6d444 R E 0x1000
```

In this case, a memory segment starting at 0x08049000 with a size of 0x6d444 is executable (ends at 0x80B6444).&#x20;

Here's how you can filter out gadgets in a specific memory segment using awk:

```
msfelfscan target -j esp | awk '{
if (strtonum($1) >= 0x08049000 && strtonum($1) <= 0x080b6444)
        print $0
}'
```

#### **ROPgadget**

{% embed url="https://github.com/JonathanSalwan/ROPgadget" %}

Benefits:

* Knows to search only executable memory regions.

Drawbacks:

* You need to use **grep** to filter out what you want. Therefore it only allows you to search by specific instructions, not by general goals.

You can use [ROPgadget](https://github.com/JonathanSalwan/ROPgadget) to print out all the ROP gadgets of a binary:

```
python3 ROPgadget.py --binary mybinary
```

#### **Pwntools**

You could try to find gadgets like this (for example a `push esp;ret` gadget):

```
rop_data = pwn.ROP(pwn.ELF('path/to/executable'))
gadgets = rop_data.find_gadget(['push esp', 'ret'])
```

But when I tried it, it didn't find the gadgets that msfelfscan and ROPgadget had found. So perhaps it's **less reliable**.

### **ROP Gadget Techniques**

#### **Write-What-Where**

{% embed url="https://trustfoundry.net/basic-rop-techniques-and-tricks/" %}

These are gadgets that allow you to arbitrarily write anything anywhere

```
mov [register1], register2
```

### **ASLR without PIE**

If the program is NOT a position-independent executable, then ROP gadgets will always be at the same location. Meaning you can construct a ROP chain to do what you want.&#x20;

In other words, if the code of the application is always in the same place. Then you can return to some place in the `.text` section which contains code you want to execute.



### **Return to stack (ASLR bypass)**

**Prerequisites**:

* **DEP/NX is not enabled (aka the stack is executable)**
* Stack canaries and other protections that interfere with what you're doing need to be turned off
* You need to control data on the stack
  * This is true with **stack overflows**
* You need a register to point to data on the stack that you control
  * This is true by default with stack overflows, because the stack pointer points to a place you control
  * But you might need to chain ROP gadgets to change the register to a suitable value
  * With the stack pointer, be wary of [shellcode corruption issues](stack-smashing.md#shellcode-corruption). Shellcode corruption did not impact my exploit when I did this (though it did occur, just not in an important place)

Here's **the idea** (in this example, the register you use is the stack pointer):

* You don't know what the address of your payload is on the stack, but the relative location of the stack pointer to your payload should always stay the same.&#x20;
* Therefore, you try to find a `jmp esp` (or similar, like `push esp;ret`) ROP gadget and jump to your payload on the stack.
