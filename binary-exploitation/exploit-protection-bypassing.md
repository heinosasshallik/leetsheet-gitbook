# Exploit Protection Bypassing

## Detect Enabled Protections <a href="#docs-internal-guid-39923e30-7fff-1eb7-44df-03cf31a836cb" id="docs-internal-guid-39923e30-7fff-1eb7-44df-03cf31a836cb"></a>

You can use the checksec script from pwntools for ELF executables:

```
pwn checksec target
```

## Return Oriented Programming <a href="#docs-internal-guid-f62655c6-7fff-59ca-6029-47674aaea71d" id="docs-internal-guid-f62655c6-7fff-59ca-6029-47674aaea71d"></a>

### **Finding ROP Gadgets**

#### **msfelfscan**

Benefits:

* Is more abstract, searches for things that get you the desired result instead of specific instructions

Drawbacks:

* Has no option to only search executable memory regions afaik.
* **Doesn't work** if you're on a 64-bit machine and trying to find ROP gadgets for a 32-bit binary

**Installation**

You need metasploit-framework:

```
sudo apt install metasploit-framework
```

Then you need to install the necessary ruby gem(s):

```
sudo gem install rex-bin_tools
```

And after that, you should be able to use msfelfscan:

```
locate msfelfscan
/usr/share/metasploit-framework/vendor/bundle/ruby/2.7.0/bin/msfelfscan
```

#### **Usage**

Useful flags:

* `-j` to look for jumps to specific places/things

For example, the following command looks for jumps to esp:

```
msfelfscan -j esp /path/to/executable
```

**Warning**: It will also display gadgets that are in non-executable memory segments.

You can use `readelf` to see which memory segments are executable. Look for LOAD types with the **E** (execute) flag. For example:

```
readelf executable --segments
Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
LOAD           0x001000 0x08049000 0x08049000 0x6d444 0x6d444 R E 0x1000
```

In this case, a memory segment starting at 0x08049000 with a size of 0x6d444 is executable (ends at 0x80B6444).&#x20;

Here's how you can filter out gadgets in a specific memory segment using awk:

```
msfelfscan target -j esp | awk '{
if (strtonum($1) >= 0x08049000 && strtonum($1) <= 0x080b6444)
        print $0
}'
```

#### **ROPgadget**

{% embed url="https://github.com/JonathanSalwan/ROPgadget" %}

Benefits:

* Knows to search only executable memory regions.

Drawbacks:

* You need to use **grep** to filter out what you want. Therefore it only allows you to search by specific instructions, not by general goals.

You can use [ROPgadget](https://github.com/JonathanSalwan/ROPgadget) to print out all the ROP gadgets of a binary:

```
python3 ROPgadget.py --binary mybinary
```

#### **Pwntools**

You could try to find gadgets like this (for example a `push esp;ret` gadget):

```
rop_data = pwn.ROP(pwn.ELF('path/to/executable'))
gadgets = rop_data.find_gadget(['push esp', 'ret'])
```

But when I tried it, it didn't find the gadgets that msfelfscan and ROPgadget had found. So perhaps it's **less reliable**.

### **ROP Gadget Techniques**

#### **Write-What-Where**

{% embed url="https://trustfoundry.net/basic-rop-techniques-and-tricks/" %}

These are gadgets that allow you to arbitrarily write anything anywhere

```
mov [register1], register2
```

### **ASLR without PIE**

If the program is NOT a position-independent executable, then ROP gadgets will always be at the same location. Meaning you can construct a ROP chain to do what you want.&#x20;

In other words, if the code of the application is always in the same place. Then you can return to some place in the `.text` section which contains code you want to execute.



### **Return to stack ASLR bypass**

#### **Prerequisites**:

* **DEP/NX is not enabled (aka the stack is executable)**
* Stack canaries and other protections that interfere with what you're doing need to be turned off
* You need to control data on the stack
  * This is true with **stack overflows**
* You need a register to point to data on the stack that you control
  * This is true by default with stack overflows, because the stack pointer points to a place you control
  * But you might need to chain ROP gadgets to change the register to a suitable value
  * With the stack pointer, be wary of [shellcode corruption issues](stack-smashing.md#shellcode-corruption). Shellcode corruption did not impact my exploit when I did this (though it did occur, just not in an important place)

#### The idea

Here's the idea (in this example, the register you use is the stack pointer):

* You don't know what the address of your payload is on the stack, but the relative location of the stack pointer to your payload should always stay the same.&#x20;
* Therefore, you try to find a `jmp esp` (or similar, like `push esp;ret`) ROP gadget and jump to your payload on the stack.

#### Exploitation

I used this in [Exploit Exercises Fusion Level01](https://exploit.education/fusion/level01/).

* Writeup: [https://github.com/heinosasshallik/infosec-knowledge/blob/master/writeups/fusion/level01/notes.txt](https://github.com/heinosasshallik/infosec-knowledge/blob/master/writeups/fusion/level01/notes.txt)

Just to test, I fuzzed the application with A's until I got a segfault. I stepped until the `ret` just before the segfault and looked at the stack:

```
[0x08049f15]> pxr 16 @ esp - 8
0xfff52ce4 0x41414141  AAAA ebx,ebp ascii ('A')
0xfff52ce8 0x41414141  AAAA ebx,ebp ascii ('A')
0xfff52cec 0x41414141  AAAA @ esp ebx,ebp ascii ('A')
0xfff52cf0 0x41414141  AAAA ebx,ebp ascii ('A')
```

This confirms that I control data on the stack around the stack pointer. So if I can find a `jmp esp` or `push esp;ret` gadget, then I can jump to a place in memory that I control. After that, I'll be able to execute any code I want.

To find a `jmp esp`, you can use [msfelfscan](exploit-protection-bypassing.md#msfelfscan):

```
fusion@fusion:~$ /opt/metasploit-framework/msfelfscan -j esp /opt/fusion/bin/level01
```

After finding the address of the JMP ESP gadget, all I had to do was overwrite the saved return pointer with the address of the gadget, and I was able to jump to code that I controlled.

_Note: You will probably land just after the address of the ROP gadget on the stack._

Overflown stack layout:

1. Filler space
2. Saved return pointer
   1. Overwrite this with the address of the ROP gadget
3. Gadget return location
   1. This is where the `jmp esp` ROP gadget will jump to
   2. Add whatever code you want to execute here

Here's how to get the shellcode for a relative jump 0x20 bytes forward using [command-line pwntools](https://docs.pwntools.com/en/stable/commandline.html):

```
pwn asm 'jmp $+0x20'
```
