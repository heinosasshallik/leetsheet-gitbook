# Stack Smashing

## Basic stack overflow with executable stack, no protections

### Overview

![Phoenix stack 5 example](https://lh6.googleusercontent.com/Z7A-yxH5Ws3mnjYADuOI8JKYgkf-yk\_kt9BukMwhIo52T8iDWhLpFCB5EAKFUcW0VSKezL7GZ-ASFCR\_L5a3BpfIy2aFiH0O6PppkIY6RgKo4pmBXl6wFaKl2opXDdV7AlrU\_v-HLr-6fKStVn\_mDg)



What you need to do:

1. Find the address of the buffer on the stack
2. Find the address of the EIP on the stack, that was pushed for the RET instruction
3. Subtract #1 from #2. That’s how much padding space you have
4. Fill the padding space with random padding
5. After the padding space, overwrite the EIP which was saved on the stack. It should point to the NOP slide in #6. Put it in the middle of the NOP slide due to differences in the stack address space (view section “Stack address changes”)
6. After the overwritten EIP, put a NOP slide. You can be generous with this, like 128 bytes for example. But making it ridiculously large may break the program.
7. After the NOP slide, put your shellcode

_Note: You can also put the shellcode inside the buffer, but the above method is better, since then you won't be limited by the buffer size._

### **Finding out how many bytes the overflow needs to be**

You need to know how many bytes you need to overflow to get to the saved return pointer. You can use the cyclic generator from pwntools to easily identify it.

You can generate the overflow like this (in ascii in this case, but you can also leave them as bytes for exploitation):

```
import pwn

number_of_bytes = 500
generator = pwn.util.cyclic.cyclic_gen()
overflow = generator.get(number_of_bytes).decode('ascii')
```

Alternatively, you can use the [pwntools command-line program](https://docs.pwntools.com/en/stable/commandline.html):

```
pwn cyclic 500
```

Use the generated overflow to cause a segfault in the application. Then look at dmesg:

```
sudo dmesg
[14515.106389] target[9460]: segfault at 61616b62 ip 0000000061616b62 sp 00000000ff9cd5f0 error 14
```

You can see that the instruction pointer was 61616b62, which corresponds to the ascii text 'aakb'. Also, it's in little endian, so it corresponds to 'bkaa' in the cyclic generator's output.&#x20;

Echo out the overflow ascii and find out where the 'bkaa' string occurs in the cyclic output. That's the place where you need to put the address you want to overflow the saved return pointer with. The amount of bytes up until that string is the amount of bytes you need to get to the return pointer on the stack from the initial overflow location.
