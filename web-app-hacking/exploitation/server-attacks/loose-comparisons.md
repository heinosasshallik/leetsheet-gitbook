# Loose Comparisons

## MySQL

{% embed url="https://dev.mysql.com/doc/refman/8.0/en/comparison-operators.html" %}

MySQL's `=` operator does loose comparisons by default. These comparisons all evaluate to true:

* `SELECT '0' = 0;`
* `SELECT '0.0' = 0;`
* `SELECT '0      ' = '0';`

_Note: Postgresql doesn't do loose comparisons by default._

## PHP

{% embed url="https://owasp.org/www-pdf-archive/PHPMagicTricks-TypeJuggling.pdf" %}

_Note: Python and JS also have loose comparisons._

Use cases:

* CSRF token bypass
* Authentication bypass
* Subverting application logic in general

PHP has loose comparisons ("==") and strict comparisons ("===")

Loose comparisons has some weird conversion rules.

JSON is really useful because you can also send ints and bools and stuff, not just strings.

Importantly, any string which has a letter or "0whatever" in the beginning is equal to int(0). If it begins with "123whatever", it's equal to int(123) !!Also TRUE == "whatever" will also always return true.

JSON: {"username":0} //Might also work with "username":true if (0 == "testusername") { //works also with (123 == "123testusername") echo "username bypassed"; }

\[+] Also, with strcmp, if they've made a check with if(!strcmp($var1, $var2)) then they've fucked up,

Use this to determine what counts as TRUE and what counts as false. http://php.net/manual/en/language.types.boolean.php

There are better options than the empty parentheses because passing the empty parentheses generates an error. If that error is caught, the exploit doesnâ€™t work. Find a better way to get strcmp to be 0 (check root-me's type juggling solutions and also the php.net website.

JSON: {"password":\[]}

if (!strcmp(\[], "testpassword")) { echo "password bypassed"; }

\[+] BTW, the same technique also works when using PHP serialized data instead of JSON!





## Other

